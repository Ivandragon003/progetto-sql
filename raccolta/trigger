
CREATE OR REPLACE FUNCTION checkRistorante()
RETURNS TRIGGER AS $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM lavora
        WHERE idRistorante = OLD.idRistorante
          AND codFiscale <> OLD.codFiscale
    ) THEN
        RAISE EXCEPTION 'Non puoi lasciare il ristorante % senza chef.', OLD.idRistorante;
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_checkRistorante
BEFORE DELETE ON lavora
FOR EACH ROW
EXECUTE FUNCTION checkRistorante();

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

CREATE OR REPLACE FUNCTION checkCorsoUtente()
RETURNS TRIGGER AS $$
DECLARE
    data_inizio TIMESTAMP;
BEGIN
    SELECT dataInizioCorso INTO data_inizio
    FROM corsoCucina
    WHERE idCorsoCucina = OLD.idCorsoCucina;

    IF NOT EXISTS (
        SELECT 1 
        FROM iscritto
        WHERE idCorsoCucina = OLD.idCorsoCucina
    ) AND data_inizio <= CURRENT_TIMESTAMP THEN
        DELETE FROM corsoCucina WHERE idCorsoCucina = OLD.idCorsoCucina;
    END IF;

    RETURN NULL; 
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_checkCorsoUtente
AFTER DELETE ON iscritto 
FOR EACH ROW
EXECUTE FUNCTION checkCorsoUtente();


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

CREATE OR REPLACE FUNCTION checkIntervalloSessione()
RETURNS TRIGGER AS $$
DECLARE
    inizio_corso TIMESTAMP;
    fine_corso   TIMESTAMP;
BEGIN
    SELECT dataInizioCorso, dataFineCorso
    INTO inizio_corso, fine_corso
    FROM corsoCucina
    WHERE idCorsoCucina = NEW.idCorsoCucina;

    IF NEW.dataInizioSessione < inizio_corso OR NEW.dataFineSessione > fine_corso THEN
        RAISE EXCEPTION 'Le date della sessione (% → %) devono essere comprese nell’intervallo del corso (% → %)',
            NEW.dataInizioSessione, NEW.dataFineSessione, inizio_corso, fine_corso;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_checkIntervalloSessione
BEFORE INSERT OR UPDATE ON Sessione
FOR EACH ROW
EXECUTE FUNCTION checkIntervalloSessione();


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
CREATE OR REPLACE FUNCTION checkPostiCorso()
RETURNS TRIGGER AS $$
DECLARE
    max_posti INT;
    numeroIscritti INT;
BEGIN
    SELECT numeroPosti INTO max_posti
    FROM corsoCucina
    WHERE idCorsoCucina = NEW.idCorsoCucina;

    SELECT COUNT(*) INTO numeroIscritti
    FROM iscritto
    WHERE idCorsoCucina = NEW.idCorsoCucina AND stato = TRUE;

    IF numeroIscritti >= max_posti THEN
        NEW.stato := FALSE;  
    ELSE
        NEW.stato := TRUE;  
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_checkPostiCorso
BEFORE INSERT ON iscritto
FOR EACH ROW
EXECUTE FUNCTION checkPostiCorso();


/////////////////////////////////////////////////////////////////////////////////////////////////////////



CREATE OR REPLACE FUNCTION checkPostiSessione()
RETURNS TRIGGER AS $$
DECLARE
    max_posti INT;
    iscritti INT;
    tipo_sessione tipoSessione;
BEGIN
    SELECT numeroPosti, tipo INTO max_posti, tipo_sessione
    FROM Sessione
    WHERE idSessione = NEW.idSessione;

    SELECT COUNT(*) INTO iscritti
    FROM adesione
    WHERE idSessione = NEW.idSessione AND stato = TRUE;

    IF tipo_sessione = 'inPresenza' THEN
        IF iscritti >= max_posti THEN
            NEW.stato := FALSE;
        ELSE
            NEW.stato := TRUE;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_checkPostiSessione
BEFORE INSERT ON adesione
FOR EACH ROW
EXECUTE FUNCTION checkPostiSessione();

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\		


CREATE OR REPLACE FUNCTION bloccoAdesioniOnline()
RETURNS TRIGGER AS $$
DECLARE
    tipo_sessione tipoSessione;
BEGIN
    SELECT tipo INTO tipo_sessione FROM Sessione WHERE idSessione = NEW.idSessione;

    IF tipo_sessione != 'inPresenza' THEN
        RAISE EXCEPTION 'Adesione permessa solo per sessioni in presenza';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_bloccoAdesioniOnline
BEFORE INSERT ON adesione
FOR EACH ROW
EXECUTE FUNCTION bloccoAdesioniOnline();




\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


CREATE OR REPLACE FUNCTION checkDataRichieste()
RETURNS TRIGGER AS $$
DECLARE
    data_inizio TIMESTAMP;
BEGIN
    SELECT dataInizioSessione INTO data_inizio
    FROM Sessione
    WHERE idSessione = NEW.idSessione;

    IF NEW.dataAdesione > data_inizio THEN
        RAISE EXCEPTION 'Impossibile mandare adesione dopo l''inizio della sessione %', NEW.idSessione;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_checkDataRichieste
BEFORE INSERT ON adesione
FOR EACH ROW
EXECUTE FUNCTION checkDataRichieste();


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

CREATE OR REPLACE FUNCTION checkPresenzaAdesione()
RETURNS TRIGGER AS $$
DECLARE
    adesione_valida INT;
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM adesione WHERE idSessione = NEW.idSessione AND codFiscale = NEW.codFiscale AND stato = TRUE
    ) THEN
        RAISE EXCEPTION 'Utente % non ha un adesione accettata per la sessione %', NEW.codFiscale, NEW.idSessione;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_checkPresenzaAdesione
BEFORE INSERT OR UPDATE ON iscritto  
FOR EACH ROW
EXECUTE FUNCTION checkPresenzaAdesione();

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
CREATE OR REPLACE FUNCTION checkIscrittoCorso()
RETURNS trigger AS $$
DECLARE
    corso_sessione INT;
BEGIN
  
    SELECT idCorsoCucina INTO corso_sessione
    FROM Sessione
    WHERE idSessione = NEW.idSessione;

    IF NOT EXISTS (
        SELECT 1
        FROM iscritto
        WHERE codFiscale = NEW.codFiscale AND idCorsoCucina = corso_sessione
    ) THEN
        RAISE EXCEPTION 
            'L''utente % non è iscritto al corso % della sessione %',
            NEW.codFiscale, corso_sessione, NEW.idSessione;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_checkSegueCorso
BEFORE INSERT OR UPDATE ON segue
FOR EACH ROW
EXECUTE FUNCTION checkIscrittoCorso();


CREATE TRIGGER trg_checkAdesioneCorso
BEFORE INSERT OR UPDATE ON adesione
FOR EACH ROW
EXECUTE FUNCTION checkIscrittoCorso();
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


CREATE OR REPLACE FUNCTION emailUnivocaPersona()
RETURNS TRIGGER AS $$
DECLARE
    cont INTEGER;
BEGIN
    
    IF TG_TABLE_NAME = 'chef' THEN
        SELECT COUNT(*) INTO cont
        FROM utente
        WHERE email = NEW.email;

        IF cont > 0 THEN
            RAISE EXCEPTION 'Email % già usata da un utente.', NEW.email;
        END IF;

   
    ELSIF TG_TABLE_NAME = 'utente' THEN
        SELECT COUNT(*) INTO cont
        FROM chef
        WHERE email = NEW.email;

        IF cont > 0 THEN
            RAISE EXCEPTION 'Email % già usata da uno chef.', NEW.email;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_emailUnivocaPersona
BEFORE INSERT OR UPDATE ON chef
FOR EACH ROW
EXECUTE FUNCTION emailUnivocaPersona();

CREATE TRIGGER trg_chk_email_utente
BEFORE INSERT OR UPDATE ON utente
FOR EACH ROW
EXECUTE FUNCTION emailUnivocaPersona();


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

CREATE OR REPLACE FUNCTION checkCorsoChef()
RETURNS TRIGGER AS $$
BEGIN
 IF NOT EXISTS (
        SELECT 1
        FROM tiene
        WHERE idCorsoCucina = OLD.idCorsoCucina AND codFiscale <> OLD.codFiscale
    ) THEN
        RAISE EXCEPTION 'Il corso % non può restare senza chef.', OLD.idCorsoCucina;
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_checkCorsoChef
BEFORE DELETE ON tiene
FOR EACH ROW
EXECUTE FUNCTION checkCorsoChef();
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
